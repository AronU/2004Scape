[proc,try_add_macro_cube]
def_int $size = inv_size(inv);
def_int $i = 0;
def_int $space = inv_freespace(inv);
def_int $total = inv_total(inv, macro_cube);
if($total > 27 | $total = 0) {
    return;
}
if (gettimer(macro_cube_split) ! ^true) {
    settimer(macro_cube_split, 16);
}
if($space > 0) {
    while ($i < $size) {
        def_obj $obj = inv_getobj(inv, $i);
        if ($obj = null) {
            inv_setslot(inv, $i, macro_cube, 1);
            return;
        }
        $i = add($i, 1);
    }
}
inv_add(inv, macro_cube, 1);
return;

[timer,macro_cube_add]
def_int $total = inv_total(inv, macro_cube);
if($total = 0) {
    cleartimer(macro_cube_add);
    return;
}
if($total = 28) {
    return;
}
~try_add_macro_cube;
mes("Oh dear, you have taken so long that the cube has replicated.");
mes("You will need to solve this one too to get the reward.");

[timer,macro_cube_split]
def_int $size = inv_size(inv);
def_int $i = 0;
def_int $space = inv_freespace(inv);
def_int $total = inv_total(inv, macro_cube);
def_int $stacked_obj = -1;
def_int $free_slot = -1;

if($total = 0) {
    cleartimer(macro_cube_split);
}

if($total < 2) {
    return;
}

if($space > 0) {
    while ($i < $size) {
        def_obj $obj = inv_getobj(inv, $i);
        if ($obj = null & $free_slot = -1) {
            // Get first free slot
            $free_slot = $i;
        } else if ($obj = macro_cube) {
            // Find a stack larger than 1
            if (inv_getnum(inv, $i) > 1) {
                $stacked_obj = $i;
            }
        }
        $i = add($i, 1);
    }

    if($stacked_obj ! -1) {
        inv_setslot(inv, $stacked_obj, macro_cube, sub(inv_getnum(inv, $stacked_obj),1));
        inv_setslot(inv, $free_slot, macro_cube, 1);
    }
}

[proc,get_shape_name](int $shape_value)(string)
switch_int($shape_value) {
    case 0 : return("Triangle");
    case 1 : return("Square");
    case 2 : return("Circle");
    case 3 : return("Star");
    case 4 : return("Half Moon");
    case default : return("Oops");
}

[proc,get_shape_colour_obj](int $shape_value, int $colour_value)(obj)
switch_int($shape_value) {
    case 0 :
        switch_int($colour_value) {
            case 0 : return(macro_cube_redtriangle);
            case 1 : return(macro_cube_bluetriangle);
            case 2 : return(macro_cube_yellowtriangle);
            case default : return(macro_cube_redtriangle);
        }
    case 1 :
        switch_int($colour_value) {
            case 0 : return(macro_cube_redsquare);
            case 1 : return(macro_cube_bluesquare);
            case 2 : return(macro_cube_yellowsquare);
            case default : return(macro_cube_redsquare);
        }
    case 2 :
        switch_int($colour_value) {
            case 0 : return(macro_cube_redcircle);
            case 1 : return(macro_cube_bluecircle);
            case 2 : return(macro_cube_yellowcircle);
            case default : return(macro_cube_redcircle);
        }
    case 3 :
        switch_int($colour_value) {
            case 0 : return(macro_cube_redstar);
            case 1 : return(macro_cube_bluestar);
            case 2 : return(macro_cube_yellowstar);
            case default : return(macro_cube_redstar);
        }
    case 4 :
        switch_int($colour_value) {
            case 0 : return(macro_cube_redhalfmoon);
            case 1 : return(macro_cube_bluehalfmoon);
            case 2 : return(macro_cube_yellowhalfmoon);
            case default : return(macro_cube_redhalfmoon);
        }
    case default :
        return(macro_cube_redtriangle);
}

[proc,get_shape_colour_name](int $colour_value)(string)
switch_int($colour_value) {
    case 0 : return("Red");
    case 1 : return("Blue");
    case 2 : return("Yellow");
    case default : return("Oops");
}

[proc,macro_cube_open]
if_openmain(macro_cube);

// 3 distinct shapes
def_int $shape_1 = random(5);
def_int $shape_2 = random(5);
def_int $shape_3 = random(5);
while ($shape_2 = $shape_1) {
    $shape_2 = random(5);
}
while ($shape_3 = $shape_1 | $shape_3 = $shape_2) {
    $shape_3 = random(5);
}

// 3 distinct colors in 254
def_int $num_1 = random(3);
def_int $num_2 = random(3);
def_int $num_3 = random(3);
while ($num_2 = $num_1) {
    $num_2 = random(3);
}
while ($num_3 = $num_1 | $num_3 = $num_2) {
    $num_3 = random(3);
}

def_obj $center_shape_obj = ~get_shape_colour_obj($shape_1, $num_1);
def_obj $side_shape_obj = ~get_shape_colour_obj($shape_2, $num_2);
def_obj $top_shape_obj = ~get_shape_colour_obj($shape_3, $num_3);

def_string $center_shape_colour = ~get_shape_colour_name($num_1);
def_string $side_shape_colour = ~get_shape_colour_name($num_2);
def_string $top_shape_colour = ~get_shape_colour_name($num_3);

if_setobject(macro_cube:center_shape_model, $center_shape_obj, 390);

if_setobject(macro_cube:side_shape_model, $side_shape_obj, 390);

if_setobject(macro_cube:top_shape_model, $top_shape_obj, 390);

def_int $question_type = random(2);
def_int $correct_answer = random(3);
def_string $center_shape_name = ~get_shape_name($shape_1);
def_string $side_shape_name = ~get_shape_name($shape_2);
def_string $top_shape_name = ~get_shape_name($shape_3);
def_string $correct_shape = "";
def_string $correct_colour = "";

switch_int($correct_answer) {
    case 0 :
        %xplamp = 0;
        $correct_shape = $center_shape_name;
        $correct_colour = $center_shape_colour;
    case 1 :
        %xplamp = 1;
        $correct_shape = $side_shape_name;
        $correct_colour = $side_shape_colour;
    case 2 :
        %xplamp = 2;
        $correct_shape = $top_shape_name;
        $correct_colour = $top_shape_colour;
}


// Answers are always center model, side model, top model
if($question_type = 0) {
    if_settext(macro_cube:question, "What colour is the <$correct_shape>?");
    if_settext(macro_cube:answer_box1, $center_shape_colour);
    if_settext(macro_cube:answer_box2, $side_shape_colour);
    if_settext(macro_cube:answer_box3, $top_shape_colour);
} else {
    if_settext(macro_cube:question, "Which shape is <$correct_colour>?");
    if_settext(macro_cube:answer_box1, $center_shape_name);
    if_settext(macro_cube:answer_box2, $side_shape_name);
    if_settext(macro_cube:answer_box3, $top_shape_name);
}

// https://www.youtube.com/watch?v=VZdOT8VYfXg // Random spin speed and direction per box
// https://www.youtube.com/watch?v=mBhMfAmgNRc // I think they made them spin slower and varying height sometime in mid - late '08..? 

// def_int $x_speed = 0;
// while ($x_speed < 7 & $x_speed > -7) {
//     $x_speed = ~random_range(-15, 15);
// }

// def_int $y_speed = 0;
// while ($y_speed < 7 & $y_speed > -7) {
//     $y_speed = ~random_range(-15, 15);
// }

// This uses an anim in 254. 
// if_setrotation(macro_cube:center_shape_model, $x_speed, $y_speed);
// if_setrotation(macro_cube:side_shape_model, $x_speed, $y_speed);
// if_setrotation(macro_cube:top_shape_model, $x_speed, $y_speed);
// if_setrotation(macro_cube:center_number_model, $x_speed, $y_speed);
// if_setrotation(macro_cube:side_number_model, $x_speed, $y_speed);
// if_setrotation(macro_cube:top_number_model, $x_speed, $y_speed);

[if_button,macro_cube:answer_button1]
if_close;
if(%xplamp = 0) {
    ~macro_cube_success;
} else {
    ~macro_cube_question_fail;
}

[if_button,macro_cube:answer_button2]
if_close;
if(%xplamp = 1) {
    ~macro_cube_success;
} else {
    ~macro_cube_question_fail;
}

[if_button,macro_cube:answer_button3]
if_close;
if(%xplamp = 2) {
    ~macro_cube_success;
} else {
    ~macro_cube_question_fail;
}

[proc,macro_cube_question_fail]
def_int $total = inv_total(inv, macro_cube);
if($total = 28) {
    mes("Oh dear, you have answered the question incorrectly.");
    return;
}
mes("Oh dear, you have answered the question incorrectly and so the cube has");
mes("replicated.");
mes("You will need to solve this one too to get the reward.");
~try_add_macro_cube;

[proc,macro_cube_success]
inv_del(inv, macro_cube, 1);
def_int $total = inv_total(inv, macro_cube);
if($total > 0) {
    mes("You have completed this cube, but there are more for you to do.");
    mes("You will need to solve them too to get the reward.");
} else {
    cleartimer(macro_cube_add);
    cleartimer(macro_cube_split);
    inv_add(inv, ~macro_cube_reward);
}

[proc,macro_cube_reward]()(namedobj, int)
def_int $random = random(116);
if (map_members = ^false) {
    $random = random(114);
}
// Gp, uncut gems or half keys only
// https://www.tip.it/runescape/pages/view/random_events.htm
// https://forum.tip.it/topic/41972-100th-strange-box/
if ($random < 50) return(coins, multiply(pow(2, ~random_range(3, 6)), 10));
if ($random < 82) return(uncut_sapphire, 1); // 32/150 uncut sapphire 
if ($random < 98) return(uncut_emerald, 1); // 16/150 uncut emerald
if ($random < 106) return(uncut_ruby, 1); // 8/150 uncut ruby
if ($random < 112) return(coins, 240); // 6/150 240 coins
if ($random < 114) return(uncut_diamond, 1); // 2/150 uncut diamond
if ($random < 115) return(keyhalf1, 1); // 1/150 half key
if ($random < 116) return(keyhalf2, 1); // 1/150 half key

[opheld5,macro_cube]
~try_add_macro_cube;

[opheld1,macro_cube]
// https://youtu.be/4nvDxoeBXlU?si=Yky4AY-6LjE0sdJr&t=34 
// TODO: This delay on opening is needed for the interface to load properly if you already had it open previously.
// Engine changes would be required to match this video because we currently send an if_close on ophelds when we clear pending actions
// Even with removing that, it still doesn't match 100% so I think it might be related to being a future client revision.
p_delay(0);
~macro_cube_open;

[opobj3,macro_cube]
// https://www.youtube.com/watch?v=Tq1t2hq5mT0 // pickup mes
mes("The mystical powers surrounding this cube prevent you from taking it.");

[proc,give_strange_box]
if (p_finduid(uid) = false) {
    return;
}

inv_add(inv, macro_cube, 1);
~objbox(macro_cube, "You have been given a Mysterious box! Click on it and answer the question correctly to get the prize inside!", 200, 0, -16);
mes("You have been given a Mysterious box! Click on it and answer the question");
mes("correctly to get the prize inside!");
// https://www.youtube.com/watch?v=VZdOT8VYfXg 90s between too long messages
settimer(macro_cube_add, 150);
// https://www.youtube.com/watch?v=4nvDxoeBXlU // unstacks itself every 10s
settimer(macro_cube_split, 16);

[proc,macro_cube_login]
def_int $total = inv_total(inv, macro_cube);
if($total > 0) {
    settimer(macro_cube_add, 150);
    settimer(macro_cube_split, 16);
}